#!/usr/bin/env node
"use strict";

function Continue(resolver) {
    var todo = [];
    var result = null;
    var C = function(then) {
        var CH = Continue( function (resolve) {
            todo.push(function() {
                try {
                    var next_result = then.apply(null,arguments);
                    if ( typeof(newVal) !== 'undefined' ) {
                        resolve(null,next_result);
                    }
                    else {
                        resolve.apply(null,arguments);
                    }
                }
                catch (X) {
                    resolve(X);
                }
            });
        });
        if (result) { process.nextTick(result) }
        return CH;
    };
    var resolve = function () {
        if (result) { throw new Error("Continuable already resolved") }
        var A = arguments;
        (result = function(){ todo.forEach(function(T){ T.apply(null,A) }); todo=[] })();
    };
    resolve.withoutErrors = function (V) { this.resolve(null,V) }
    resolver( resolve );
    return C;
}

var def = function(value,defVal) {
    return typeof(value) !== 'undefined' ? value : defVal;
};

function Promise() {
    var P = {deferred:{}};
    var C = Continue(function (resolve) {
        P.resolve = function (value) { 
            if ( typeof(value)==='object' && typeof(value.then)==='function' ) {
                value.then(P.resolve,P.reject);
            }
            else {
                resolve(null,value);
            }
        };
        P.resolve.withCallback = function(E,V) {
            if (E) { P.reject(E) } else { P.resolve(V) }
        };
        P.reject = function(value) {
            resolve(value);
        };
    });

    P.deferred.then = function(then,error) {
        var PC = Promise();
        error = error || function (E) { return E };
        C(function (E,V) {
            try {
                if (E) {
                    PC.reject(def( error(E), E ));
                }
                else {
                    PC.resolve(def( then(V), V ));
                }
            }
            catch (X) {
                PC.reject(X);
            }
        });
        return PC.deferred;
    };
    return P;
}

var foo = Continue( function (resolve) {
    resolve(new Error("BOOM"),"THIS1");
});
foo(function(E,V) { console.log("CONTINUE EARLY RESOLVE1:",E,V); if (E) throw E; return V; })
   (function(E,V) { console.log("CONTINUE EARLY RESOLVE2:",E,V); if (E) throw E; return V; })
   (function(E,V) { console.log("CONTINUE EARLY RESOLVE3:",E,V) });

var bar = Continue( function (resolve) { process.nextTick(function(){ resolve(null,"THIS2") }) } );
bar(function(E,V) { console.log("CONTINUE LATE RESOLVE1:",E,V) });
bar(function(E,V) { console.log("CONTINUE LATE RESOLVE2:",E,V) });

var promise = Promise();
function pstart() {
   return promise.deferred;
}

function ok() {
    var N = Promise();
    promise.resolve(N.deferred);
    N.resolve("yay");
}

function nok() {
    promise.reject("boo");
}

var P = pstart();

var P2 = P.then(function (M) { console.log("PROMISE1:",M); throw new Error(M) }, function (M) { console.log("PROMISE1 (err):",M) })
          .then(function (M) { console.log("PROMISE2:",M) }, function (M) { console.log("PROMISE2: (err)",M) });

ok();

P.then(function (M) { console.log("PROMISE3:",M) }, function (M) { console.log("PROMISE3: (err)",M) });

P2.then(function (M) { console.log("PROMISE4:",M) }, function (M) { console.log("PROMISE4: (err)",M) });
